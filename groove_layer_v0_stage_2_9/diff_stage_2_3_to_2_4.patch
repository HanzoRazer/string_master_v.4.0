--- stage_2_3/groove_layer/engine.py
+++ stage_2_4/groove_layer/engine.py
@@ -1,14 +1,57 @@
+from __future__ import annotations
 
-from typing import Dict, Any
+from dataclasses import dataclass, asdict
+from typing import Dict, Any, Optional
 
-def compute_groove_layer_control(payload: Dict[str, Any]) -> Dict[str, Any]:
+
+@dataclass
+class GrooveStateV0:
+    """Minimal state container for Stage 2.4.
+
+    - No learning/latents yet.
+    - Only enough memory to avoid thrash and support recovery.
+    """
+    last_loop_policy: str = "none"
+    last_density: str = "medium"
+    stable_windows: int = 0  # consecutive stable windows
+
+
+def _avg_conf(events) -> float:
+    if not events:
+        return 0.0
+    return sum(e.get("confidence", 0.0) for e in events) / len(events)
+
+
+def _is_stable(event_count: int, avg_conf: float) -> bool:
+    # Stability heuristic (Stage 2.4):
+    return event_count >= 8 and avg_conf >= 0.90
+
+
+def compute_groove_layer_control(payload: Dict[str, Any], state: Optional[GrooveStateV0] = None) -> Dict[str, Any]:
+    """Compute Groove Layer v0 control intent.
+
+    Stage 2.4 adds:
+      - Recovery behavior (Vector 03)
+      - Hysteresis (require 2 stable windows to fully exit corrective modes)
+    """
+    if state is None:
+        state = GrooveStateV0()
+
     engine_context = payload.get("engine_context")
     events = payload.get("events", [])
     device_id = payload.get("device_id")
     session_id = payload.get("session_id")
 
+    prior = payload.get("prior_state_hint") or {}
+    if prior:
+        state.last_loop_policy = prior.get("last_loop_policy", state.last_loop_policy)
+        state.last_density = prior.get("last_density", state.last_density)
+
     # --- Missing engine context â†’ conservative freeze (Vector 04)
     if engine_context is None:
+        state.stable_windows = 0
+        state.last_loop_policy = "none"
+        state.last_density = "medium"
         return {
             "schema_id": "groove_layer_control",
             "schema_version": "v0",
@@ -21,15 +64,20 @@
                 "feel": {"feel_policy": "straight", "grid": "quarter", "click_policy": "off"},
                 "assist": {"assist_policy": "minimal", "ghost_drums": "off", "count_in_bars": 0},
                 "change_policy": {"allow_modulation": False, "allow_tempo_change_events": False, "allow_density_probes": False}
-            }
+            },
+            "debug": {"state": asdict(state), "reason": "missing_engine_context"}
         }
 
-    # --- Basic window stats
     event_count = len(events)
-    avg_conf = sum(e.get("confidence", 0) for e in events) / event_count if event_count else 0
+    avg_conf = _avg_conf(events)
+    stable = _is_stable(event_count, avg_conf)
 
-    # --- Instability gate (Vector 02)
-    if avg_conf < 0.85 or event_count < 8:
+    state.stable_windows = state.stable_windows + 1 if stable else 0
+
+    # --- Instability corrective mode (Vector 02)
+    if (avg_conf < 0.85) or (event_count < 8):
+        state.last_loop_policy = "micro_loop"
+        state.last_density = "sparse"
         return {
             "schema_id": "groove_layer_control",
             "schema_version": "v0",
@@ -42,10 +90,40 @@
                 "feel": {"feel_policy": "straight", "grid": engine_context.get("grid", "eighth"), "click_policy": "prominent"},
                 "assist": {"assist_policy": "supportive", "ghost_drums": "light", "count_in_bars": 2},
                 "change_policy": {"allow_modulation": False, "allow_tempo_change_events": False, "allow_density_probes": False}
-            }
+            },
+            "debug": {"state": asdict(state), "reason": "unstable_gate"}
         }
 
-    # --- Stable follow-player behavior (Vector 01)
+    # --- Recovery / hysteresis (Vector 03)
+    # If we were in micro_loop recently, don't snap straight to "none":
+    #   - first stable window: loop_section (gentler)
+    #   - second stable window: none
+    if state.last_loop_policy == "micro_loop":
+        if state.stable_windows < 2:
+            state.last_loop_policy = "loop_section"
+            state.last_density = "medium"
+            return {
+                "schema_id": "groove_layer_control",
+                "schema_version": "v0",
+                "device_id": device_id,
+                "session_id": session_id,
+                "controls": {
+                    "tempo": {"policy": "follow_player", "nudge_strength": 0.25, "max_delta_pct_per_min": 5},
+                    "arrangement": {"density_target": "medium", "instrumentation_policy": "keep_layers", "dynamics_follow": "soft_follow"},
+                    "loop": {"policy": "loop_section", "length_bars": 4, "exit_condition": "stability_recovered"},
+                    "feel": {"feel_policy": engine_context.get("feel", "straight"), "grid": engine_context.get("grid", "eighth"), "click_policy": "subtle"},
+                    "assist": {"assist_policy": "standard", "ghost_drums": "off", "count_in_bars": 0},
+                    "change_policy": {"allow_modulation": False, "allow_tempo_change_events": True, "allow_density_probes": True}
+                },
+                "debug": {"state": asdict(state), "reason": "recovery_deescalate"}
+            }
+        # second stable window: fully recovered
+        state.last_loop_policy = "none"
+        state.last_density = "medium"
+
+    # --- Stable baseline (Vector 01)
+    state.last_loop_policy = "none"
+    state.last_density = "medium"
     return {
         "schema_id": "groove_layer_control",
         "schema_version": "v0",
@@ -58,5 +136,6 @@
             "feel": {"feel_policy": engine_context.get("feel", "straight"), "grid": engine_context.get("grid", "eighth"), "click_policy": "subtle"},
             "assist": {"assist_policy": "standard", "ghost_drums": "off", "count_in_bars": 1},
             "change_policy": {"allow_modulation": False, "allow_tempo_change_events": True, "allow_density_probes": True}
-        }
+        },
+        "debug": {"state": asdict(state), "reason": "stable_baseline"}
     }

--- stage_2_3/tests/test_groove_layer_stage_2_3.py
+++ stage_2_4/tests/test_groove_layer_stage_2_3.py
@@ -1,6 +1,5 @@
-
 import json
-from groove_layer.engine import compute_groove_layer_control
+from groove_layer.engine import compute_groove_layer_control, GrooveStateV0
 
 def load(p):
     with open(p) as f:
@@ -8,14 +7,27 @@
 
 def test_vector_01():
     payload = load("fixtures/vectors/01_stable_follow_player.json")
-    expected = load("fixtures/expected/01_controls.json")
     out = compute_groove_layer_control(payload)
-    assert out["controls"]["tempo"]["policy"] == expected["controls"]["tempo"]["policy"]
+    assert out["controls"]["tempo"]["policy"] == "follow_player"
 
 def test_vector_02():
     payload = load("fixtures/vectors/02_unstable_reduce_density_micro_loop.json")
     out = compute_groove_layer_control(payload)
     assert out["controls"]["loop"]["policy"] == "micro_loop"
+    assert out["controls"]["arrangement"]["density_target"] == "sparse"
+
+def test_vector_03_recovery_first_window_deescalates_to_loop_section():
+    payload = load("fixtures/vectors/03_recovery_exit_loop.json")
+    state = GrooveStateV0(last_loop_policy="micro_loop", last_density="sparse", stable_windows=0)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["controls"]["loop"]["policy"] == "loop_section"
+    assert out["controls"]["arrangement"]["density_target"] == "medium"
+
+def test_vector_03_recovery_second_window_exits_loop():
+    payload = load("fixtures/vectors/03_recovery_exit_loop.json")
+    state = GrooveStateV0(last_loop_policy="micro_loop", last_density="sparse", stable_windows=1)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["controls"]["loop"]["policy"] == "none"
 
 def test_vector_04():
     payload = load("fixtures/vectors/04_missing_tempo_freeze_conservative.json")

