--- stage_2_5/groove_layer/engine.py
+++ stage_2_6/groove_layer/engine.py
@@ -6,12 +6,13 @@
 
 @dataclass
 class GrooveStateV0:
-    """Minimal state container for Stage 2.5.
-
-    Adds probing + revert on top of Stage 2.4 recovery/hysteresis.
-
-    - No learning/latents yet.
-    - Probing is conservative: only when already stable, and always reversible.
+    """Minimal state container for Stage 2.6.
+
+    Adds probe scheduling + cooldown decay on top of Stage 2.5.
+
+    Concepts:
+    - `probe_cooldown_windows`: blocks starting new probes (decays each window).
+    - `next_probe_in_windows`: deterministic scheduler so probes don't fire every stable window.
     """
     last_loop_policy: str = "none"
     last_density: str = "medium"
@@ -25,6 +26,10 @@
     probe_baseline_density: str = "medium"
     probe_cooldown_windows: int = 0  # blocks re-probing for a while after revert
 
+    # Probe scheduling (v0 deterministic)
+    next_probe_in_windows: int = 0  # counts down; when hits 0 and stable, we may probe
+    probe_interval_windows: int = 3 # schedule next probe this many stable windows later
+
 
 def _avg_conf(events) -> float:
     if not events:
@@ -33,12 +38,10 @@
 
 
 def _is_stable(event_count: int, avg_conf: float) -> bool:
-    # Stability heuristic:
     return event_count >= 8 and avg_conf >= 0.90
 
 
 def _seed_from_prior_hint(state: GrooveStateV0, prior: Dict[str, Any]) -> None:
-    # Allow fixtures to seed prior corrective/probe mode without persistence.
     state.last_loop_policy = prior.get("last_loop_policy", state.last_loop_policy)
     state.last_density = prior.get("last_density", state.last_density)
     state.stable_windows = prior.get("stable_windows", state.stable_windows)
@@ -50,13 +53,27 @@
     state.probe_baseline_density = prior.get("probe_baseline_density", state.probe_baseline_density)
     state.probe_cooldown_windows = prior.get("probe_cooldown_windows", state.probe_cooldown_windows)
 
+    state.next_probe_in_windows = prior.get("next_probe_in_windows", state.next_probe_in_windows)
+    state.probe_interval_windows = prior.get("probe_interval_windows", state.probe_interval_windows)
+
+
+def _controls_baseline(engine_context: Dict[str, Any]) -> Dict[str, Any]:
+    return {
+        "tempo": {"policy": "follow_player", "nudge_strength": 0.2, "max_delta_pct_per_min": 5},
+        "arrangement": {"density_target": "medium", "instrumentation_policy": "keep_layers", "dynamics_follow": "soft_follow"},
+        "loop": {"policy": "none", "length_bars": 4, "exit_condition": "manual"},
+        "feel": {"feel_policy": engine_context.get("feel", "straight"), "grid": engine_context.get("grid", "eighth"), "click_policy": "subtle"},
+        "assist": {"assist_policy": "standard", "ghost_drums": "off", "count_in_bars": 1},
+        "change_policy": {"allow_modulation": False, "allow_tempo_change_events": True, "allow_density_probes": True}
+    }
+
 
 def compute_groove_layer_control(payload: Dict[str, Any], state: Optional[GrooveStateV0] = None) -> Dict[str, Any]:
     """Compute Groove Layer v0 control intent.
 
-    Stage 2.5 adds:
-      - Vector 05 probing + revert
-      - Conservative probe gating and cooldown
+    Stage 2.6 adds Vector 06:
+      - Probe cooldown decay (explicit + testable)
+      - Probe scheduling (deterministic spacing between probes)
     """
     if state is None:
         state = GrooveStateV0()
@@ -99,23 +116,27 @@
     avg_conf = _avg_conf(events)
     stable = _is_stable(event_count, avg_conf)
 
-    # Cooldown ticks down on every window when context exists
+    # --- Decay timers (Vector 06)
     if state.probe_cooldown_windows > 0:
         state.probe_cooldown_windows -= 1
 
+    # Scheduler only ticks down on stable windows (avoid "countdown while struggling")
+    if stable and state.next_probe_in_windows > 0:
+        state.next_probe_in_windows -= 1
+
     state.stable_windows = state.stable_windows + 1 if stable else 0
 
     # --- Hard instability corrective mode (Vector 02)
-    # If we are probing and instability is detected, revert immediately.
+    # If probing and instability is detected, revert immediately + cooldown.
     if (avg_conf < 0.85) or (event_count < 8):
         if state.probe_active:
-            # Revert probe immediately
             state.probe_active = False
             state.probe_kind = ""
             state.probe_variant = ""
             state.probe_windows = 0
-            state.probe_cooldown_windows = 8  # blocks re-probing for ~2 minutes in v0 terms
+            state.probe_cooldown_windows = 8
             state.last_density = state.probe_baseline_density
+            state.next_probe_in_windows = state.probe_interval_windows  # push future probes out
 
             return {
                 "schema_id": "groove_layer_control",
@@ -174,81 +195,59 @@
         state.last_loop_policy = "none"
         state.last_density = "medium"
 
-    # --- Probing (Vector 05)
-    # Probe definition (v0):
-    # - Only when already stable for >=2 windows
-    # - Only when not in cooldown
-    # - Probe changes ONE thing (density), for 1 window, then stops (v0 minimal)
-    allow_probes = True
-    if state.probe_cooldown_windows > 0:
-        allow_probes = False
-
-    if stable and allow_probes:
-        # If probe is active, continue it for 1 window; otherwise start a new one occasionally.
-        if state.probe_active:
-            state.probe_windows += 1
-            # v0: end probe after 1 window; keep whatever was chosen (future versions evaluate success)
-            if state.probe_windows >= 1:
-                state.probe_active = False
-                state.probe_kind = ""
-                state.probe_variant = ""
-                state.probe_windows = 0
-            # Output stays on the probed density for this window
-            return {
-                "schema_id": "groove_layer_control",
-                "schema_version": "v0",
-                "device_id": device_id,
-                "session_id": session_id,
-                "controls": {
-                    "tempo": {"policy": "follow_player", "nudge_strength": 0.2, "max_delta_pct_per_min": 5},
-                    "arrangement": {"density_target": state.last_density, "instrumentation_policy": "keep_layers", "dynamics_follow": "soft_follow"},
-                    "loop": {"policy": "none", "length_bars": 4, "exit_condition": "manual"},
-                    "feel": {"feel_policy": engine_context.get("feel", "straight"), "grid": engine_context.get("grid", "eighth"), "click_policy": "subtle"},
-                    "assist": {"assist_policy": "standard", "ghost_drums": "off", "count_in_bars": 1},
-                    "change_policy": {"allow_modulation": False, "allow_tempo_change_events": True, "allow_density_probes": True}
-                },
-                "debug": {"state": asdict(state), "reason": "probe_active"}
-            }
-
-        # Start a probe only when stable_windows == 2 (deterministic trigger for fixtures)
-        if state.stable_windows >= 2 and state.stable_windows % 2 == 0:
-            state.probe_active = True
-            state.probe_kind = "density"
-            state.probe_variant = "dense"
-            state.probe_baseline_density = "medium"
-            state.last_density = "dense"
+    # --- Probing + scheduling (Vector 06)
+    # Rules (v0):
+    # - Never start a probe if cooldown > 0.
+    # - Only start a probe on stable windows, after at least 2 stable windows.
+    # - Only start if scheduler counter is 0.
+    # - When a probe starts, set next_probe_in_windows = probe_interval_windows.
+    if stable and (state.probe_cooldown_windows == 0) and (state.stable_windows >= 2) and (state.next_probe_in_windows == 0) and (not state.probe_active):
+        state.probe_active = True
+        state.probe_kind = "density"
+        state.probe_variant = "dense"
+        state.probe_baseline_density = "medium"
+        state.last_density = "dense"
+        state.probe_windows = 0
+        state.next_probe_in_windows = max(1, int(state.probe_interval_windows))
+
+        controls = _controls_baseline(engine_context)
+        controls["arrangement"]["density_target"] = "dense"
+        return {
+            "schema_id": "groove_layer_control",
+            "schema_version": "v0",
+            "device_id": device_id,
+            "session_id": session_id,
+            "controls": controls,
+            "debug": {"state": asdict(state), "reason": "probe_start_scheduled_density_dense"}
+        }
+
+    # Probe active: keep the probed density for 1 window then end probe (v0 minimal)
+    if state.probe_active:
+        state.probe_windows += 1
+        controls = _controls_baseline(engine_context)
+        controls["arrangement"]["density_target"] = state.last_density
+        if state.probe_windows >= 1:
+            state.probe_active = False
+            state.probe_kind = ""
+            state.probe_variant = ""
             state.probe_windows = 0
-
-            return {
-                "schema_id": "groove_layer_control",
-                "schema_version": "v0",
-                "device_id": device_id,
-                "session_id": session_id,
-                "controls": {
-                    "tempo": {"policy": "follow_player", "nudge_strength": 0.2, "max_delta_pct_per_min": 5},
-                    "arrangement": {"density_target": "dense", "instrumentation_policy": "keep_layers", "dynamics_follow": "soft_follow"},
-                    "loop": {"policy": "none", "length_bars": 4, "exit_condition": "manual"},
-                    "feel": {"feel_policy": engine_context.get("feel", "straight"), "grid": engine_context.get("grid", "eighth"), "click_policy": "subtle"},
-                    "assist": {"assist_policy": "standard", "ghost_drums": "off", "count_in_bars": 1},
-                    "change_policy": {"allow_modulation": False, "allow_tempo_change_events": True, "allow_density_probes": True}
-                },
-                "debug": {"state": asdict(state), "reason": "probe_start_density_dense"}
-            }
+        return {
+            "schema_id": "groove_layer_control",
+            "schema_version": "v0",
+            "device_id": device_id,
+            "session_id": session_id,
+            "controls": controls,
+            "debug": {"state": asdict(state), "reason": "probe_active"}
+        }
 
     # --- Stable baseline (Vector 01)
     state.last_density = "medium"
+    controls = _controls_baseline(engine_context)
     return {
         "schema_id": "groove_layer_control",
         "schema_version": "v0",
         "device_id": device_id,
         "session_id": session_id,
-        "controls": {
-            "tempo": {"policy": "follow_player", "nudge_strength": 0.2, "max_delta_pct_per_min": 5},
-            "arrangement": {"density_target": "medium", "instrumentation_policy": "keep_layers", "dynamics_follow": "soft_follow"},
-            "loop": {"policy": "none", "length_bars": 4, "exit_condition": "manual"},
-            "feel": {"feel_policy": engine_context.get("feel", "straight"), "grid": engine_context.get("grid", "eighth"), "click_policy": "subtle"},
-            "assist": {"assist_policy": "standard", "ghost_drums": "off", "count_in_bars": 1},
-            "change_policy": {"allow_modulation": False, "allow_tempo_change_events": True, "allow_density_probes": True}
-        },
+        "controls": controls,
         "debug": {"state": asdict(state), "reason": "stable_baseline"}
     }

--- stage_2_5/tests/test_groove_layer_stage_2_3.py
+++ stage_2_6/tests/test_groove_layer_stage_2_3.py
@@ -44,6 +44,23 @@
     payload = load("fixtures/vectors/05b_probe_revert_on_instability.json")
     state = GrooveStateV0(probe_active=True, probe_kind="density", probe_variant="dense", probe_baseline_density="medium", last_density="dense", stable_windows=2)
     out = compute_groove_layer_control(payload, state=state)
-    # Revert triggers and we end up in the instability safety mode
     assert out["controls"]["loop"]["policy"] == "micro_loop"
     assert out["debug"]["reason"] == "probe_revert_then_unstable_gate"
+
+def test_vector_06a_cooldown_blocks_probe():
+    payload = load("fixtures/vectors/06a_cooldown_blocks_probe.json")
+    state = GrooveStateV0(stable_windows=2, probe_cooldown_windows=2, next_probe_in_windows=0)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["controls"]["arrangement"]["density_target"] == "medium"
+
+def test_vector_06b_cooldown_expired_probe_starts():
+    payload = load("fixtures/vectors/06b_cooldown_expired_probe_starts.json")
+    state = GrooveStateV0(stable_windows=1, probe_cooldown_windows=1, next_probe_in_windows=0)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["controls"]["arrangement"]["density_target"] == "dense"
+
+def test_vector_06c_scheduler_blocks_until_zero():
+    payload = load("fixtures/vectors/06c_scheduler_blocks_until_zero.json")
+    state = GrooveStateV0(stable_windows=2, probe_cooldown_windows=0, next_probe_in_windows=1)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["controls"]["arrangement"]["density_target"] == "medium"

