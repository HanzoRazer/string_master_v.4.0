# CBSP21 — Complete Boundary-Safe Processing Protocol

**Policy Classification:** AI Governance / Model Risk Management
**Version:** 1.0
**Effective Date:** 2026-01-01
**Owner:** Office of AI Governance
**Review Cycle:** Annual

---

## 1. Purpose

CBSP21 defines the **minimum completeness standard** for any automated system scanning or processing a document, file, or folder. Its goal is to eliminate *partial-capture errors, hallucinated fill-ins, and scoping drift* by ensuring the system processes **no less than 95% of the actual source content** before generating outputs.

This policy prevents:
- Misinterpretation caused by partial document review
- Hallucinated or fabricated fill-in content
- Regulatory and compliance exposure from inaccurate output
- Software defects originating from incomplete code extraction

---

## 2. Core Principle

> **Do not reason from partial inputs.**
> **Do not summarize, transform, or implement code until ≥95% of the source has been fully scanned and verified.**

---

## 3. Scope

CBSP21 applies when the system is instructed to:
- scan
- review
- summarize
- refactor
- generate output based on
- extract code from

any **document, file, folder, or structured dataset**.

This standard applies to any AI-assisted processing of:
- Documents
- Files
- Folders or repositories
- Structured datasets
- Source code collections

---

## 4. Coverage Requirement

### 4.1 Required Minimum

The AI system must:
- Attempt to process **100% of the provided content**
- Confirm **no less than 95% actual coverage** before continuing

### 4.2 Prohibited Actions

The system must not:
- Generate conclusions from excerpts
- Fill in gaps based on probability or inference
- Treat missing sections as irrelevant
- Execute or produce runnable code from partial extracts
- Apply partial policy interpretation
- Guess missing content
- Treat prose outside code blocks as optional
- Act on incomplete scans
- Infer structure beyond what is explicitly present

---

## 5. Verification Procedure

Implementations of this policy must include:

### 5.1 Unit Enumeration

All relevant units must be identified (files, sections, blocks, code regions).

### 5.2 Coverage Measurement

Coverage must be measured by character or block count:

```
coverage = scanned / total
```

### 5.3 Coverage Confirmation

Output may proceed **only if**:

```
coverage >= 0.95
```

### 5.4 Audit Logging

Systems must log one of the following:

- `CBSP21 Coverage Confirmed: 97.3%`
- `CBSP21 Coverage Failure: 83.4% — Output Halted`

Logs must be retained in accordance with the Record Retention Policy.

---

## 6. Mandatory Stop Conditions

The system MUST **immediately stop and request clarification** when any of the following occur:

- Content appears truncated
- Code blocks are incomplete
- A file reference is listed but content not present
- A fence marker ``` is opened but not closed
- Binary or unreadable content is detected
- Coverage cannot reach ≥95%
- Missing dependency content

**Failure to meet coverage = NO OUTPUT.**

The only allowed response is a request for the missing content.

---

## 7. Safety & Boundary Rules

1. **Never invent missing code or text**
2. **Never assume omitted content is irrelevant**
3. **Never merge partial fragments into runnable logic**
4. **Never treat commentary-embedded code as authoritative unless structured**

---

## 8. Structured Input & Immutability

### 8.1 Structured Input Preference

To reduce scan ambiguity, the system should prefer:
- Full file contents
- Or unified diffs
- Or fenced blocks with declared paths:

```
FILE: path/to/file.py
<full content>
```

### 8.2 Immutable Ground Truth (`full_source/`)

The directory `full_source/` represents the **authoritative, immutable copy** of the material being evaluated under CBSP21.

- `full_source/` **MUST NOT** be modified, rewritten, or generated by the AI system or any downstream process used for coverage calculation.
- Only human-controlled or upstream source-of-record systems may update `full_source/`.
- All CBSP21 coverage calculations MUST treat `full_source/` as **read-only ground truth**.
- Any attempt by automation to write into `full_source/` is considered a **policy violation** and MUST fail the process.

Derived or partially scanned content should be stored separately, e.g. in `scanned_source/`, and may be safely overwritten or regenerated as needed.

---

## 9. Output Timing

The system may only produce output **after ALL the following are true:**

- Coverage ≥ 95%
- No unresolved missing content
- No unclosed code blocks
- No skipped embedded code regions
- All STOP CONDITIONS cleared

---

## 10. Integrity Guarantees

CBSP21 ensures:

- Deterministic processing
- No accidental truncation
- No hallucinated code fill-ins
- Stable reproducibility
- Clear safety boundaries

---

## 11. Audit Statement Format

When output is produced, include a brief line:

```
CBSP21 Coverage: 98.2% — All completeness conditions satisfied.
```

If coverage is below threshold:

```
CBSP21 Coverage: 83.5% — Output prohibited. Please provide remaining content.
```

---

## 12. Compliance & Enforcement

Failure to comply with this policy may result in:

- Output rejection
- Model access suspension
- Investigation under the AI Risk Framework
- Escalation to Legal / Compliance if customer-impacting

---

## 13. Roles & Responsibilities

| Role | Responsibility |
|------|----------------|
| **System Owners** | Ensure implementation controls exist |
| **Developers** | Integrate coverage verification into workflows |
| **AI Risk & Governance** | Conduct periodic assurance reviews |
| **Internal Audit** | Validate enforcement integrity |
| **Security** | Monitor anomalous behavior |

---

## 14. Exceptions

Exceptions require formal approval from:

- Head of AI Governance
- Legal Counsel
- Data Security Officer

Documented justification is mandatory.

---

## 15. Review & Revision

This standard will be reviewed annually or upon:
- Regulatory requirement changes
- Introduction of new AI systems
- Incident or audit findings

---

## 16. Reusable Guardrail Instruction

You can paste this anywhere the bot needs the directive:

> **Scan the provided {document | file | folder | path} completely in accordance with protocol `CBSP21.md`. You must process no less than 95% of the total informational content before producing conclusions, summaries, or transformations. If any portion of the source cannot be scanned, stop and request clarification rather than assuming or inferring missing content.**

---

## 17. Implementation Scripts

### 17.1 Python Coverage Script (Single File or Folder)

Save as: `scripts/cbsp21_coverage_check.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage Check

Calculates how much of the original content has been scanned/captured
and enforces a minimum coverage threshold (default: 95%).

- If both paths are files -> compare file sizes.
- If both paths are directories -> compare total bytes of all files.
- If one is a file and the other is a directory -> fail with an error.

Usage examples:

    # Single file
    python cbsp21_coverage_check.py \
        --full-path full_source.txt \
        --scanned-path scanned_source.txt

    # Folders (e.g., full repo vs scanned subset)
    python cbsp21_coverage_check.py \
        --full-path full_source \
        --scanned-path scanned_source \
        --threshold 0.97
"""

import argparse
import sys
from pathlib import Path


def total_bytes_in_dir(root: Path) -> int:
    """Sum bytes of all regular files under a directory (recursive)."""
    return sum(
        f.stat().st_size
        for f in root.rglob("*")
        if f.is_file()
    )


def compute_bytes(path: Path) -> int:
    """Return total bytes for a file or a directory."""
    if path.is_file():
        return path.stat().st_size
    if path.is_dir():
        return total_bytes_in_dir(path)
    raise FileNotFoundError(f"Path is neither file nor directory: {path}")


def main() -> int:
    parser = argparse.ArgumentParser(description="CBSP21 Coverage Check")
    parser.add_argument(
        "--full-path",
        required=True,
        help="Path to the full (ground truth) document or folder.",
    )
    parser.add_argument(
        "--scanned-path",
        required=True,
        help="Path to the scanned/captured document or folder.",
    )
    parser.add_argument(
        "--threshold",
        type=float,
        default=0.95,
        help="Minimum required coverage ratio (default: 0.95).",
    )

    args = parser.parse_args()
    full_path = Path(args.full_path)
    scanned_path = Path(args.scanned_path)
    threshold = args.threshold

    if not full_path.exists():
        print(f"full_path does not exist: {full_path}")
        return 1

    if not scanned_path.exists():
        print(f"scanned_path does not exist: {scanned_path}")
        return 1

    # Require both to be same kind (both files OR both directories)
    if full_path.is_file() and not scanned_path.is_file():
        print("Type mismatch: full_path is a file but scanned_path is not.")
        return 1
    if full_path.is_dir() and not scanned_path.is_dir():
        print("Type mismatch: full_path is a directory but scanned_path is not.")
        return 1

    try:
        full_bytes = compute_bytes(full_path)
        scanned_bytes = compute_bytes(scanned_path)
    except FileNotFoundError as e:
        print(f"{e}")
        return 1

    if full_bytes == 0:
        print("full_path appears empty (0 bytes) - cannot compute coverage.")
        return 1

    coverage = scanned_bytes / full_bytes
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}% (threshold {threshold * 100:.2f}%)")

    if coverage < threshold:
        print("Coverage below required threshold - output prohibited under CBSP21.")
        return 1

    print("Coverage requirement satisfied - CBSP21 conditions met.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 17.2 Python Coverage Script with JSON Audit Log

Save as: `scripts/cbsp21_coverage_with_audit.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage & Audit Logger

Usage:
    python scripts/cbsp21_coverage_with_audit.py \
        --full full_source \
        --scanned scanned_source \
        --threshold 0.95 \
        --log logs/cbsp21_audit.jsonl
"""

import argparse
import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any


def total_bytes(root: Path) -> int:
    return sum(
        f.stat().st_size
        for f in root.rglob("*")
        if f.is_file()
    )


def build_audit_record(
    full: Path,
    scanned: Path,
    full_bytes: int,
    scanned_bytes: int,
    coverage: float,
    threshold: float,
    status: str,
) -> Dict[str, Any]:
    return {
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "policy": "CBSP21",
        "full_path": str(full),
        "scanned_path": str(scanned),
        "full_bytes": full_bytes,
        "scanned_bytes": scanned_bytes,
        "coverage_ratio": coverage,
        "repo_coverage_percent": round(coverage * 100, 2),
        "threshold": threshold,
        "status": status,  # "pass" | "fail"
        # Optional CI metadata (if running in GitHub Actions, etc.)
        "ci": {
            "run_id": os.getenv("GITHUB_RUN_ID"),
            "run_number": os.getenv("GITHUB_RUN_NUMBER"),
            "sha": os.getenv("GITHUB_SHA"),
            "ref": os.getenv("GITHUB_REF"),
        },
    }


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--full", required=True, help="Path to full_source (immutable)")
    parser.add_argument("--scanned", required=True, help="Path to scanned_source")
    parser.add_argument("--threshold", type=float, default=0.95)
    parser.add_argument(
        "--log",
        default="logs/cbsp21_audit.jsonl",
        help="Path to append-only JSONL audit log",
    )
    args = parser.parse_args()

    full_root = Path(args.full)
    scanned_root = Path(args.scanned)
    threshold = args.threshold
    log_path = Path(args.log)

    # Basic existence checks
    if not full_root.exists():
        print(f"full_source path not found: {full_root}")
        return 1
    if not scanned_root.exists():
        print(f"scanned_source path not found: {scanned_root}")
        return 1

    # Immutability note: this script NEVER writes to full_root; it only reads.

    full_size = total_bytes(full_root)
    scanned_size = total_bytes(scanned_root)

    if full_size == 0:
        print("full_source appears empty - cannot compute coverage.")
        return 1

    coverage = scanned_size / full_size
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}% (threshold {threshold * 100:.2f}%)")

    status = "pass" if coverage >= threshold else "fail"

    # Ensure log directory exists
    log_path.parent.mkdir(parents=True, exist_ok=True)

    record = build_audit_record(
        full=full_root,
        scanned=scanned_root,
        full_bytes=full_size,
        scanned_bytes=scanned_size,
        coverage=coverage,
        threshold=threshold,
        status=status,
    )

    # Append JSON line
    with log_path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False))
        f.write("\n")

    if status == "fail":
        print("Coverage below CBSP21 threshold - output prohibited.")
        return 1

    print("Coverage requirement satisfied - CBSP21 conditions met.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 17.3 PowerShell Coverage Script

Save as: `scripts/Check-CBSP21Coverage.ps1`

```powershell
param(
    [Parameter(Mandatory = $true)]
    [string]$FullPath,

    [Parameter(Mandatory = $true)]
    [string]$ScannedPath,

    [double]$Threshold = 0.95
)

function Get-TotalBytes($Path) {
    Get-ChildItem -Recurse -File -Force $Path `
        | Measure-Object -Property Length -Sum `
        | Select-Object -ExpandProperty Sum
}

if (-not (Test-Path $FullPath)) {
    Write-Error "Full source path not found: $FullPath"
    exit 1
}

if (-not (Test-Path $ScannedPath)) {
    Write-Error "Scanned source path not found: $ScannedPath"
    exit 1
}

$fullBytes = Get-TotalBytes $FullPath
$scannedBytes = Get-TotalBytes $ScannedPath

if (-not $fullBytes) {
    Write-Error "Full source appears empty - cannot compute coverage."
    exit 1
}

$coverage = $scannedBytes / $fullBytes
$percent = "{0:N2}" -f ($coverage * 100)

Write-Host "CBSP21 Coverage: $percent%"

if ($coverage -lt $Threshold) {
    Write-Host "Coverage below $($Threshold * 100)% - Output prohibited."
    exit 1
}
else {
    Write-Host "Coverage requirement satisfied."
    exit 0
}
```

### 17.4 GitHub Actions Workflow

Save as: `.github/workflows/cbsp21_coverage.yml`

```yaml
name: CBSP21 Coverage Gate

on:
  pull_request:
  push:
    branches: [ main, master ]

jobs:
  cbsp21-coverage:
    runs-on: ubuntu-latest

    env:
      CBSP21_THRESHOLD: "0.95"   # change if policy updates

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Run CBSP21 Coverage Check
        run: |
          python <<'PYCODE'
          import os
          from pathlib import Path

          THRESHOLD = float(os.getenv("CBSP21_THRESHOLD", "0.95"))
          full = Path("full_source")
          scanned = Path("scanned_source")

          def total_bytes(root: Path):
              return sum(
                  f.stat().st_size
                  for f in root.rglob("*")
                  if f.is_file()
              )

          if not full.exists():
              raise SystemExit("full_source/ not found")
          if not scanned.exists():
              raise SystemExit("scanned_source/ not found")

          full_size = total_bytes(full)
          scanned_size = total_bytes(scanned)

          coverage = scanned_size / full_size if full_size else 0
          percentage = coverage * 100

          print(f"CBSP21 Coverage: {percentage:.2f}%")

          if coverage < THRESHOLD:
              print("Coverage below policy threshold. Output prohibited.")
              raise SystemExit(1)
          else:
              print("Coverage requirement satisfied.")
          PYCODE
```

---

## 18. Revision Notes

| Rev | Date | Notes |
|-----|------|-------|
| 1.0 | 2026-01-01 | Initial release. Establishes ≥95% coverage rule, STOP CONDITIONS, structured input preference, immutability rules, audit declaration requirement, and implementation scripts. |
| 1.1 | 2026-01-02 | Added repo-enforced CI gates, patch packet format validation, enhanced scripts with improved error handling, and operational rules. |
| 1.2 | 2026-01-03 | Added Section 23: PR-Level Enforcement (CBSP21 as real repo gate with manifest validation, `check_cbsp21_gate.py` script, and `cbsp21_gate.yml` workflow). |
| 1.3 | 2026-01-03 | Added Section 24: Diff Review Gate (pre-commit behavior change review, redundancy check protocol, recovery procedure). |
| 1.4 | 2026-01-03 | Added Sections 25-27: Enhanced Patch Input Manifest with diff articulation requirements, behavior preservation gate, and `check_cbsp21_patch_input.py` CI enforcement. |
| 1.5 | 2026-01-03 | Added Section 25.3 Diff-Range Lock; updated Section 27 with diff_range enforcement; renamed coverage metrics to `repo_coverage_percent` (byte ratio) vs `file_context_coverage_percent` (per-file manifest coverage). |

---

## 19. Repo Layout for CI Enforcement

Create these directories at repo root (or customize paths in workflows):

```
cbsp21/
  full_source/        # immutable ground truth (human controlled)
  scanned_source/     # scanned / captured representation used for coverage
  patch_packets/      # optional: structured FILE: packets (for patch-format rule)
logs/                 # optional: audit logs output
scripts/cbsp21/       # the gate scripts
```

---

## 20. Enhanced Implementation Scripts

### 20.1 Coverage Check (Enhanced)

**Path:** `scripts/cbsp21/cbsp21_coverage_check.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage Check

Calculates how much of the original content has been scanned/captured
and enforces a minimum coverage threshold (default: 95%).

- If both paths are files -> compare file sizes.
- If both paths are directories -> compare total bytes of all files.
- If one is a file and the other is a directory -> fail with an error.

Usage examples:

    # Directories
    python scripts/cbsp21/cbsp21_coverage_check.py \
        --full-path cbsp21/full_source \
        --scanned-path cbsp21/scanned_source \
        --threshold 0.95
"""

import argparse
from pathlib import Path


def total_bytes_in_dir(root: Path) -> int:
    """Sum bytes of all regular files under a directory (recursive)."""
    return sum(
        f.stat().st_size
        for f in root.rglob("*")
        if f.is_file()
    )


def compute_bytes(path: Path) -> int:
    """Return total bytes for a file or a directory."""
    if path.is_file():
        return path.stat().st_size
    if path.is_dir():
        return total_bytes_in_dir(path)
    raise ValueError(f"Path not found: {path}")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--full-path", required=True)
    ap.add_argument("--scanned-path", required=True)
    ap.add_argument("--threshold", type=float, default=0.95)
    args = ap.parse_args()

    full = Path(args.full_path)
    scanned = Path(args.scanned_path)

    if not full.exists():
        raise SystemExit(f"Full path does not exist: {full}")
    if not scanned.exists():
        raise SystemExit(f"Scanned path does not exist: {scanned}")

    # Guard: file vs dir mismatch
    if full.is_file() != scanned.is_file():
        raise SystemExit("CBSP21 ERROR: full-path and scanned-path must both be files or both be directories.")

    full_bytes = compute_bytes(full)
    scanned_bytes = compute_bytes(scanned)

    if not full_bytes:
        raise SystemExit("CBSP21 ERROR: full source appears empty - cannot compute coverage.")

    coverage = scanned_bytes / full_bytes
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}%")
    print(f"  full_bytes   = {full_bytes}")
    print(f"  scanned_bytes= {scanned_bytes}")
    print(f"  threshold    = {args.threshold * 100:.2f}%")

    if coverage < args.threshold:
        print("CBSP21 FAIL: Coverage below policy threshold. Output prohibited.")
        return 1

    print("CBSP21 PASS: Coverage requirement satisfied.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 20.2 Coverage + Audit Logger (Enhanced)

**Path:** `scripts/cbsp21/cbsp21_coverage_with_audit.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage & Audit Logger

Usage:
    python scripts/cbsp21/cbsp21_coverage_with_audit.py \
        --full cbsp21/full_source \
        --scanned cbsp21/scanned_source \
        --threshold 0.95 \
        --log logs/cbsp21_audit.jsonl
"""

import argparse
import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict


def total_bytes_in_dir(root: Path) -> int:
    return sum(f.stat().st_size for f in root.rglob("*") if f.is_file())


def compute_bytes(path: Path) -> int:
    if path.is_file():
        return path.stat().st_size
    if path.is_dir():
        return total_bytes_in_dir(path)
    raise ValueError(f"Path not found: {path}")


def audit_record(
    *,
    full: Path,
    scanned: Path,
    full_bytes: int,
    scanned_bytes: int,
    coverage: float,
    threshold: float,
    status: str,
) -> Dict[str, Any]:
    return {
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "policy": "CBSP21",
        "full_path": str(full),
        "scanned_path": str(scanned),
        "full_bytes": full_bytes,
        "scanned_bytes": scanned_bytes,
        "coverage_ratio": coverage,
        "repo_coverage_percent": round(coverage * 100, 2),
        "threshold": threshold,
        "status": status,  # "pass" | "fail"
        # Optional CI metadata (GitHub Actions)
        "ci": {
            "github_run_id": os.getenv("GITHUB_RUN_ID"),
            "github_sha": os.getenv("GITHUB_SHA"),
            "github_ref": os.getenv("GITHUB_REF"),
            "github_actor": os.getenv("GITHUB_ACTOR"),
            "github_repo": os.getenv("GITHUB_REPOSITORY"),
        },
    }


def append_jsonl(path: Path, rec: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(rec, ensure_ascii=False) + "\n")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--full", required=True)
    ap.add_argument("--scanned", required=True)
    ap.add_argument("--threshold", type=float, default=0.95)
    ap.add_argument("--log", required=True)
    args = ap.parse_args()

    full = Path(args.full)
    scanned = Path(args.scanned)
    log = Path(args.log)

    if not full.exists():
        print(f"CBSP21 FAIL: full path missing: {full}")
        rec = audit_record(full=full, scanned=scanned, full_bytes=0, scanned_bytes=0,
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    if not scanned.exists():
        print(f"CBSP21 FAIL: scanned path missing: {scanned}")
        rec = audit_record(full=full, scanned=scanned, full_bytes=compute_bytes(full), scanned_bytes=0,
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    # Guard: mismatch
    if full.is_file() != scanned.is_file():
        print("CBSP21 FAIL: full and scanned must both be files or both be directories.")
        rec = audit_record(full=full, scanned=scanned, full_bytes=compute_bytes(full), scanned_bytes=compute_bytes(scanned),
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    full_bytes = compute_bytes(full)
    scanned_bytes = compute_bytes(scanned)

    if not full_bytes:
        print("CBSP21 FAIL: full source empty.")
        rec = audit_record(full=full, scanned=scanned, full_bytes=0, scanned_bytes=scanned_bytes,
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    coverage = scanned_bytes / full_bytes
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}% (threshold {args.threshold * 100:.2f}%)")

    status = "pass" if coverage >= args.threshold else "fail"
    rec = audit_record(
        full=full,
        scanned=scanned,
        full_bytes=full_bytes,
        scanned_bytes=scanned_bytes,
        coverage=coverage,
        threshold=args.threshold,
        status=status,
    )
    append_jsonl(log, rec)

    if status == "fail":
        print("CBSP21 FAIL: Coverage below policy threshold. Output prohibited.")
        return 1

    print("CBSP21 PASS: Coverage requirement satisfied.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 20.3 Patch Packet Format Validator

This enforces structured input rules:
- Must contain at least one `FILE: path/to/file.ext`
- Must have balanced triple-backtick fences
- Optional: blocks "..." placeholder lines inside code fences

**Path:** `scripts/cbsp21/check_patch_packet_format.py`

```python
#!/usr/bin/env python
"""
CBSP21 Patch Packet Format Rule

Validates that patch packets are structured and safe to scan:
- Must include at least one line starting with "FILE: "
- Code fences (```) must be balanced
- Optional: disallow "..." placeholder inside code fences (common truncation)

Usage:
    python scripts/cbsp21/check_patch_packet_format.py --glob "cbsp21/patch_packets/**/*.*"
"""

import argparse
import glob
from pathlib import Path


def balanced_fences(text: str) -> bool:
    return text.count("```") % 2 == 0


def has_file_headers(text: str) -> bool:
    return any(line.startswith("FILE: ") for line in text.splitlines())


def has_ellipsis_inside_code_fence(text: str) -> bool:
    in_fence = False
    for line in text.splitlines():
        if line.strip().startswith("```"):
            in_fence = not in_fence
            continue
        if in_fence and line.strip() == "...":
            return True
    return False


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--glob", required=True, help="Glob of packet files to validate.")
    ap.add_argument("--disallow-ellipsis-in-code", action="store_true")
    args = ap.parse_args()

    files = [Path(p) for p in glob.glob(args.glob, recursive=True)]
    files = [p for p in files if p.is_file()]

    if not files:
        print("CBSP21 Patch Packet: no files matched; skipping.")
        return 0

    failed = False

    for path in files:
        txt = path.read_text(encoding="utf-8", errors="ignore")

        if not has_file_headers(txt):
            print(f"CBSP21 PATCH FAIL: Missing FILE headers in {path}")
            failed = True

        if not balanced_fences(txt):
            print(f"CBSP21 PATCH FAIL: Unbalanced ``` fences in {path}")
            failed = True

        if args.disallow_ellipsis_in_code and has_ellipsis_inside_code_fence(txt):
            print(f"CBSP21 PATCH FAIL: Found '...' placeholder inside code fence in {path}")
            failed = True

    if failed:
        return 1

    print("CBSP21 Patch Packet: PASS")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 20.4 CI Workflow: Coverage Gate

Runs only when CBSP21 material changes, so normal PRs are not blocked.

**Path:** `.github/workflows/cbsp21_coverage_gate.yml`

```yaml
name: CBSP21 Coverage Gate

on:
  pull_request:
    paths:
      - "cbsp21/**"
      - "scripts/cbsp21/**"
  push:
    branches: [ main, master ]
    paths:
      - "cbsp21/**"
      - "scripts/cbsp21/**"

jobs:
  cbsp21-coverage:
    runs-on: ubuntu-latest

    env:
      CBSP21_THRESHOLD: "0.95"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: CBSP21 Coverage + Audit
        run: |
          python scripts/cbsp21/cbsp21_coverage_with_audit.py \
            --full cbsp21/full_source \
            --scanned cbsp21/scanned_source \
            --threshold $CBSP21_THRESHOLD \
            --log logs/cbsp21_audit.jsonl

      - name: Upload CBSP21 audit log
        uses: actions/upload-artifact@v4
        with:
          name: cbsp21_audit
          path: logs/cbsp21_audit.jsonl
```

### 20.5 CI Workflow: Patch Packet Format

Enforces structured `FILE:` packet format when patch packets change.

**Path:** `.github/workflows/cbsp21_patch_packet_format.yml`

```yaml
name: CBSP21 Patch Packet Format

on:
  pull_request:
    paths:
      - "cbsp21/patch_packets/**"
      - "scripts/cbsp21/**"

jobs:
  cbsp21-patch-format:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Validate CBSP21 patch packets
        run: |
          python scripts/cbsp21/check_patch_packet_format.py \
            --glob "cbsp21/patch_packets/**/*.*" \
            --disallow-ellipsis-in-code
```

---

## 21. Operational Rules

### 21.1 Reconstituting a Chat / Ensuring Completeness

1. Put the authoritative material into:
   - `cbsp21/full_source/` (read-only by convention)

2. Put the scanned/captured material into:
   - `cbsp21/scanned_source/`

3. CI enforces **≥95% coverage**.

### 21.2 Submitting Patch Packets Safely

Put them in `cbsp21/patch_packets/` using:

```text
FILE: services/api/app/whatever.py
<full content or a full diff>
```

CI enforces:
- At least one `FILE:` header
- Balanced code fences
- No "..." truncation inside code fences

---

## 22. Optional Hardening

If you decide you want CBSP21 enforced for *all PRs touching governed areas* (RMOS/CAM/etc.), add another workflow trigger:

- If PR touches `services/api/app/rmos/**` or `packages/client/src/components/rmos/**`
- Then require `cbsp21/full_source` + `cbsp21/scanned_source` exist and pass

This is not enabled by default because it can block everyday development unless the team is ready for that discipline.

---

## 23. PR-Level Enforcement: CBSP21 as a Real Repo Gate

CBSP21 serves **two complementary functions**:

1. **Prevents under-scanning** — ensures AI systems don't reason from partial inputs
2. **Catches redundant/regressive patches** — detects when sandbox patches duplicate or conflict with existing code

To make this enforceable at the PR level (not just a reminder), the following components are provided:

### 23.1 PR Manifest: `.cbsp21/patch_input.json`

Every PR that modifies code/config must include a manifest declaring:
- Which files were changed
- What source files were scanned to produce the changes
- Coverage metrics per changed file

**Template:** `.cbsp21/patch_input.json.example`

```json
{
  "$schema": "cbsp21_patch_input_v1",
  "pr_title": "ci(governance): add artifact contract validator",
  "changed_files": [
    {
      "path": "scripts/governance/validate_run_artifact_contract.py",
      "action": "add",
      "scanned_sources": ["docs/ENDPOINT_TRUTH_MAP.md", "services/api/app/rmos/runs_router.py"],
      "file_context_coverage_percent": 97.2
    },
    {
      "path": ".github/workflows/run_artifact_contract_gate.yml",
      "action": "add",
      "scanned_sources": [".github/workflows/artifact_linkage.yml"],
      "file_context_coverage_percent": 100.0
    }
  ],
  "overall_file_context_coverage": 98.6,
  "notes": "Validator reads existing artifacts; does not create them."
}
```

### 23.2 Gate Script: `scripts/ci/check_cbsp21_gate.py`

This script:
- Detects code/config changes in the PR (via `git diff`)
- Requires `.cbsp21/patch_input.json` manifest
- Enforces **file-level coverage** (default min `0.95`) for every changed "code" file
- Exits non-zero if coverage requirements not met

```python
#!/usr/bin/env python3
"""
CBSP21 PR Gate

Validates that PRs touching code/config have a valid patch_input.json manifest
with sufficient coverage declarations.

Env:
  CBSP21_MIN_COVERAGE     default 0.95
  CBSP21_MANIFEST_PATH    default .cbsp21/patch_input.json
  CBSP21_SKIP_EXTENSIONS  default .md,.txt,.json (non-code files)

Usage:
  python scripts/ci/check_cbsp21_gate.py
"""

from __future__ import annotations

import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Set


def get_changed_files() -> List[str]:
    """Get files changed in this PR (vs origin/main)."""
    try:
        result = subprocess.run(
            ["git", "diff", "--name-only", "origin/main...HEAD"],
            capture_output=True, text=True, check=True
        )
        return [f.strip() for f in result.stdout.strip().split("\n") if f.strip()]
    except subprocess.CalledProcessError:
        # Fallback: compare to HEAD~1
        result = subprocess.run(
            ["git", "diff", "--name-only", "HEAD~1"],
            capture_output=True, text=True, check=True
        )
        return [f.strip() for f in result.stdout.strip().split("\n") if f.strip()]


def is_code_file(path: str, skip_exts: Set[str]) -> bool:
    """Check if file is a code file (not docs, not config-only)."""
    ext = Path(path).suffix.lower()
    if ext in skip_exts:
        return False
    # Code file extensions
    code_exts = {".py", ".ts", ".tsx", ".js", ".jsx", ".vue", ".yaml", ".yml", ".sh", ".ps1"}
    return ext in code_exts


def main() -> int:
    min_coverage = float(os.getenv("CBSP21_MIN_COVERAGE", "0.95"))
    manifest_path = Path(os.getenv("CBSP21_MANIFEST_PATH", ".cbsp21/patch_input.json"))
    skip_exts_raw = os.getenv("CBSP21_SKIP_EXTENSIONS", ".md,.txt")
    skip_exts = {s.strip().lower() for s in skip_exts_raw.split(",") if s.strip()}

    changed_files = get_changed_files()
    code_files = [f for f in changed_files if is_code_file(f, skip_exts)]

    if not code_files:
        print("CBSP21 GATE: No code files changed - skipping manifest check.")
        return 0

    print(f"CBSP21 GATE: {len(code_files)} code file(s) changed:")
    for f in code_files:
        print(f"  - {f}")

    if not manifest_path.exists():
        print(f"\n❌ CBSP21 GATE FAIL: Missing manifest at {manifest_path}")
        print("   PRs changing code must include a patch_input.json manifest.")
        print("   See .cbsp21/patch_input.json.example for template.")
        return 1

    try:
        manifest: Dict[str, Any] = json.loads(manifest_path.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, OSError) as e:
        print(f"❌ CBSP21 GATE FAIL: Invalid manifest: {e}")
        return 1

    # Check that all code files are declared in manifest
    declared_paths = {cf["path"] for cf in manifest.get("changed_files", [])}
    missing = [f for f in code_files if f not in declared_paths]

    if missing:
        print(f"\n❌ CBSP21 GATE FAIL: Changed files not declared in manifest:")
        for m in missing:
            print(f"  - {m}")
        return 1

    # Check coverage per file
    violations: List[str] = []
    for cf in manifest.get("changed_files", []):
        path = cf.get("path", "")
        cov = cf.get("file_context_coverage_percent", 0)
        if cov is None:
            cov = 0
        cov_ratio = cov / 100.0 if cov > 1 else cov

        if path in code_files and cov_ratio < min_coverage:
            violations.append(f"{path}: {cov_ratio*100:.1f}% < {min_coverage*100:.1f}%")

    if violations:
        print(f"\n❌ CBSP21 GATE FAIL: Coverage below threshold ({min_coverage*100:.0f}%):")
        for v in violations:
            print(f"  - {v}")
        return 1

    overall = manifest.get("overall_file_context_coverage", 100)
    print(f"\n✅ CBSP21 GATE PASS: All code files declared with sufficient coverage.")
    print(f"   Overall file context coverage: {overall}%")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 23.3 CI Workflow: `cbsp21_gate.yml`

**Path:** `.github/workflows/cbsp21_gate.yml`

```yaml
name: CBSP21 PR Gate

on:
  pull_request:
    paths:
      - "services/**"
      - "packages/**"
      - "scripts/**"
      - ".github/workflows/**"

jobs:
  cbsp21-pr-gate:
    runs-on: ubuntu-latest

    env:
      CBSP21_MIN_COVERAGE: "0.95"
      CBSP21_MANIFEST_PATH: ".cbsp21/patch_input.json"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need history for git diff

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: CBSP21 PR Gate Check
        run: python scripts/ci/check_cbsp21_gate.py
```

### 23.4 Workflow Integration

When contributing code changes:

1. **Before PR:** Create `.cbsp21/patch_input.json` declaring:
   - Changed files
   - Sources scanned (context gathered)
   - Coverage percentages

2. **On PR:** CI runs `check_cbsp21_gate.py`:
   - Validates manifest exists
   - Confirms all changed code files are declared
   - Enforces coverage threshold per file

3. **On Failure:** Either:
   - Add missing context scans and update manifest
   - Or request exemption via documented exception process (Section 14)

### 23.5 Exemptions

Some PRs legitimately don't need full coverage validation:
- Pure documentation changes (`.md`, `.txt`)
- Auto-generated files (declared in `.cbsp21/exemptions.json`)
- Emergency hotfixes (require post-merge audit)

To exempt specific paths, add to `.cbsp21/exemptions.json`:

```json
{
  "exempt_patterns": [
    "**/*.generated.ts",
    "**/migrations/**",
    "docs/**"
  ]
}
```

---

## 24. Diff Review Gate: Pre-Commit Behavior Change Review

### 24.1 Purpose

This section addresses a critical failure mode: **AI agents declaring patches "redundant" based on keyword matches, then applying changes that silently alter or restrict existing functionality**.

The Diff Review Gate requires:
1. **Explicit diff presentation** before commits with behavior changes
2. **User confirmation** for any changes that add guards, restrictions, or alter control flow
3. **Functional coverage verification** — not just keyword presence

### 24.2 When Diff Review is Required

| Risk Level | Trigger | Requirement |
|------------|---------|-------------|
| **Low** | Pure additions (new files, new functions) | No diff review required |
| **Medium** | Modifications to existing functions | Show diff, await confirmation |
| **High** | Changes that add guards, disable features, alter control flow | Show diff + explain impact, await explicit approval |

### 24.3 Redundancy Check Protocol

Before declaring a patch "REDUNDANT", the AI agent MUST:

1. **Keyword scan**: Search for function/variable names from patch
2. **Functional equivalence check**: Verify the *behavior* matches, not just the *presence*
3. **Coverage analysis**: For each feature in the patch, confirm:
   - Feature exists AND
   - Feature is complete AND
   - No gaps in implementation

Example of **incomplete implementation** (incorrectly flagged as redundant):
```
Patch requests: Full decision_history list in hover
Codebase has: auditHoverText() exists — but only shows LAST record
Result: NOT redundant — patch adds missing functionality
```

### 24.4 Pre-Commit Checklist for Behavior Changes

Before committing changes with `behavior_change: "medium"` or `"high"`:

```markdown
## Pre-Commit Review

- [ ] Diff shown to user (not just described)
- [ ] Behavior change clearly explained
- [ ] Impact on existing workflows documented
- [ ] User explicitly approved (not just silence)

If any guard/restriction is added:
- [ ] Existing functionality preserved OR explicitly deprecated
- [ ] Fallback behavior documented
- [ ] Migration path provided if breaking
```

### 24.5 Recovery Procedure

If a behavior-changing commit was pushed without review:

1. **Identify**: `git diff HEAD~1 HEAD -- <file>`
2. **Assess impact**: What functionality was altered?
3. **Decide**: Revert, amend, or accept with documentation
4. **Document**: Add to `.cbsp21/incident_log.json` if functionality was lost

### 24.6 Revision Notes Update

| Rev | Date | Notes |
|-----|------|-------|
| 1.3 | 2026-01-03 | Added Section 24: Diff Review Gate (pre-commit behavior change review, redundancy check protocol, recovery procedure). |

---

## 25. Patch Input Manifest (Required)

Every non-trivial change MUST include a patch manifest at:

```
.cbsp21/patch_input.json
```

This is the **first line of defense** against:

- under-scanning (missing the real change)
- falsely declaring a patch "redundant" when it contains small but important deltas
- regressions introduced by "helpful" guardrails that subtly change behavior

The manifest is the reviewer-facing contract. It must be **updated whenever the diff changes**.

### 25.1 Required Fields (v1)

- `schema_version`: `"cbsp21_patch_input_v1"`
- `patch_id`: short stable ID for the patch (e.g., `BUNDLE_12`, `FIX_409_GUARD`, etc.)
- `title`: one line
- `intent`: 1–3 sentences
- `change_type`: `code|docs|ci|mixed`
- `behavior_change`: `none|compatible|breaking`
- `risk_level`: `low|medium|high`
- `scope.paths_in_scope`: directories this patch is allowed to touch
- `scope.files_expected_to_change`: explicit list of files you expect to touch
- `diff_articulation.what_changed`: 5–15 bullets of what actually changed
- `diff_articulation.why_not_redundant`: explain what is different vs prior implementation
- `verification.commands_run`: commands run (or "not run: <reason>")

### 25.2 Hard Rule

If you touch a file that is **not** listed in `files_expected_to_change` or `paths_in_scope`, the patch is **not eligible** until the manifest is updated.

(Reason: this is how we stop "drive-by" edits from slipping in unnoticed.)

### 25.3 Diff-Range Lock (Required)

Every patch manifest MUST declare the diff range used to compute changed files, and must include the exact changed-file list derived from that range.

**Required fields:**

- `diff_range.base`: e.g. `"origin/main"`
- `diff_range.head`: e.g. `"HEAD"`
- `changed_files_count`: integer
- `changed_files_exact`: string[] (paths)

**Hard rule:**

CI MUST compute changed files from `diff_range` and require that:

1. `set(changed_files_exact) == set(actual_changed_files)`
2. All code files are covered by the manifest

This is the mechanical "no circling" lock — you cannot claim a diff range and then omit files from it.

---

## 26. Diff Review Gate (Behavior Preservation)

Before merging (or before accepting a bot-generated patch), you MUST complete a **Diff Review Gate**:

### 26.1 Show the Diff

- Provide `git diff` (or a patch file) for review.
- Call out any changes that alter conditions/guards/defaults, even if "minor".

### 26.2 State Behavior Impact Explicitly

You must answer these in the manifest (`diff_articulation` + `behavior_change`):

- What inputs now fail that previously passed?
- What outputs changed (shape, fields, ordering, defaults)?
- What edge cases were tightened/relaxed?

### 26.3 No "Redundant" Declaration Without Proof

A change can only be labeled "redundant" if **one** of these is true:

- `git diff` is empty, OR
- the changes are purely formatting/comments, OR
- you provide a short equivalence argument **plus** at least one validation command that demonstrates no behavior change.

Anything else is "non-redundant" by definition.

---

## 27. Repo-Enforced Gate — Patch Input + Diff Articulation

CI MUST fail if:

- `.cbsp21/patch_input.json` is missing, OR
- required fields are missing/invalid, OR
- files changed are not declared in `files_expected_to_change` or `paths_in_scope`, OR
- `behavior_change != "none"` but `diff_articulation.why_not_redundant` is empty or too short, OR
- `diff_range` is missing, OR
- `changed_files_exact` differs from actual git diff result for the declared `diff_range`.

Reference implementation (repo scripts):

- `scripts/ci/check_cbsp21_patch_input.py`
- workflow: `.github/workflows/cbsp21_patch_input_gate.yml`

This gate is intentionally small and mechanical: it doesn't "judge" the code — it enforces that we *described* the code change accurately.

---

**End of CBSP21**

