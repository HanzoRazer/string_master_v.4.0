# CBSP21 — Complete Boundary-Safe Processing Protocol

**Policy Classification:** AI Governance / Model Risk Management
**Version:** 1.0
**Effective Date:** 2026-01-01
**Owner:** Office of AI Governance
**Review Cycle:** Annual

---

## 1. Purpose

CBSP21 defines the **minimum completeness standard** for any automated system scanning or processing a document, file, or folder. Its goal is to eliminate *partial-capture errors, hallucinated fill-ins, and scoping drift* by ensuring the system processes **no less than 95% of the actual source content** before generating outputs.

This policy prevents:
- Misinterpretation caused by partial document review
- Hallucinated or fabricated fill-in content
- Regulatory and compliance exposure from inaccurate output
- Software defects originating from incomplete code extraction

---

## 2. Core Principle

> **Do not reason from partial inputs.**
> **Do not summarize, transform, or implement code until ≥95% of the source has been fully scanned and verified.**

---

## 3. Scope

CBSP21 applies when the system is instructed to:
- scan
- review
- summarize
- refactor
- generate output based on
- extract code from

any **document, file, folder, or structured dataset**.

This standard applies to any AI-assisted processing of:
- Documents
- Files
- Folders or repositories
- Structured datasets
- Source code collections

---

## 4. Coverage Requirement

### 4.1 Required Minimum

The AI system must:
- Attempt to process **100% of the provided content**
- Confirm **no less than 95% actual coverage** before continuing

### 4.2 Prohibited Actions

The system must not:
- Generate conclusions from excerpts
- Fill in gaps based on probability or inference
- Treat missing sections as irrelevant
- Execute or produce runnable code from partial extracts
- Apply partial policy interpretation
- Guess missing content
- Treat prose outside code blocks as optional
- Act on incomplete scans
- Infer structure beyond what is explicitly present

---

## 5. Verification Procedure

Implementations of this policy must include:

### 5.1 Unit Enumeration

All relevant units must be identified (files, sections, blocks, code regions).

### 5.2 Coverage Measurement

Coverage must be measured by character or block count:

```
coverage = scanned / total
```

### 5.3 Coverage Confirmation

Output may proceed **only if**:

```
coverage >= 0.95
```

### 5.4 Audit Logging

Systems must log one of the following:

- `CBSP21 Coverage Confirmed: 97.3%`
- `CBSP21 Coverage Failure: 83.4% — Output Halted`

Logs must be retained in accordance with the Record Retention Policy.

---

## 6. Mandatory Stop Conditions

The system MUST **immediately stop and request clarification** when any of the following occur:

- Content appears truncated
- Code blocks are incomplete
- A file reference is listed but content not present
- A fence marker ``` is opened but not closed
- Binary or unreadable content is detected
- Coverage cannot reach ≥95%
- Missing dependency content

**Failure to meet coverage = NO OUTPUT.**

The only allowed response is a request for the missing content.

---

## 7. Safety & Boundary Rules

1. **Never invent missing code or text**
2. **Never assume omitted content is irrelevant**
3. **Never merge partial fragments into runnable logic**
4. **Never treat commentary-embedded code as authoritative unless structured**

---

## 8. Structured Input & Immutability

### 8.1 Structured Input Preference

To reduce scan ambiguity, the system should prefer:
- Full file contents
- Or unified diffs
- Or fenced blocks with declared paths:

```
FILE: path/to/file.py
<full content>
```

### 8.2 Immutable Ground Truth (`full_source/`)

The directory `full_source/` represents the **authoritative, immutable copy** of the material being evaluated under CBSP21.

- `full_source/` **MUST NOT** be modified, rewritten, or generated by the AI system or any downstream process used for coverage calculation.
- Only human-controlled or upstream source-of-record systems may update `full_source/`.
- All CBSP21 coverage calculations MUST treat `full_source/` as **read-only ground truth**.
- Any attempt by automation to write into `full_source/` is considered a **policy violation** and MUST fail the process.

Derived or partially scanned content should be stored separately, e.g. in `scanned_source/`, and may be safely overwritten or regenerated as needed.

---

## 9. Output Timing

The system may only produce output **after ALL the following are true:**

- Coverage ≥ 95%
- No unresolved missing content
- No unclosed code blocks
- No skipped embedded code regions
- All STOP CONDITIONS cleared

---

## 10. Integrity Guarantees

CBSP21 ensures:

- Deterministic processing
- No accidental truncation
- No hallucinated code fill-ins
- Stable reproducibility
- Clear safety boundaries

---

## 11. Audit Statement Format

When output is produced, include a brief line:

```
CBSP21 Coverage: 98.2% — All completeness conditions satisfied.
```

If coverage is below threshold:

```
CBSP21 Coverage: 83.5% — Output prohibited. Please provide remaining content.
```

---

## 12. Compliance & Enforcement

Failure to comply with this policy may result in:

- Output rejection
- Model access suspension
- Investigation under the AI Risk Framework
- Escalation to Legal / Compliance if customer-impacting

---

## 13. Roles & Responsibilities

| Role | Responsibility |
|------|----------------|
| **System Owners** | Ensure implementation controls exist |
| **Developers** | Integrate coverage verification into workflows |
| **AI Risk & Governance** | Conduct periodic assurance reviews |
| **Internal Audit** | Validate enforcement integrity |
| **Security** | Monitor anomalous behavior |

---

## 14. Exceptions

Exceptions require formal approval from:

- Head of AI Governance
- Legal Counsel
- Data Security Officer

Documented justification is mandatory.

---

## 15. Review & Revision

This standard will be reviewed annually or upon:
- Regulatory requirement changes
- Introduction of new AI systems
- Incident or audit findings

---

## 16. Reusable Guardrail Instruction

You can paste this anywhere the bot needs the directive:

> **Scan the provided {document | file | folder | path} completely in accordance with protocol `CBSP21.md`. You must process no less than 95% of the total informational content before producing conclusions, summaries, or transformations. If any portion of the source cannot be scanned, stop and request clarification rather than assuming or inferring missing content.**

---

## 17. Implementation Scripts

### 17.1 Python Coverage Script (Single File or Folder)

Save as: `scripts/cbsp21_coverage_check.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage Check

Calculates how much of the original content has been scanned/captured
and enforces a minimum coverage threshold (default: 95%).

- If both paths are files -> compare file sizes.
- If both paths are directories -> compare total bytes of all files.
- If one is a file and the other is a directory -> fail with an error.

Usage examples:

    # Single file
    python cbsp21_coverage_check.py \
        --full-path full_source.txt \
        --scanned-path scanned_source.txt

    # Folders (e.g., full repo vs scanned subset)
    python cbsp21_coverage_check.py \
        --full-path full_source \
        --scanned-path scanned_source \
        --threshold 0.97
"""

import argparse
import sys
from pathlib import Path


def total_bytes_in_dir(root: Path) -> int:
    """Sum bytes of all regular files under a directory (recursive)."""
    return sum(
        f.stat().st_size
        for f in root.rglob("*")
        if f.is_file()
    )


def compute_bytes(path: Path) -> int:
    """Return total bytes for a file or a directory."""
    if path.is_file():
        return path.stat().st_size
    if path.is_dir():
        return total_bytes_in_dir(path)
    raise FileNotFoundError(f"Path is neither file nor directory: {path}")


def main() -> int:
    parser = argparse.ArgumentParser(description="CBSP21 Coverage Check")
    parser.add_argument(
        "--full-path",
        required=True,
        help="Path to the full (ground truth) document or folder.",
    )
    parser.add_argument(
        "--scanned-path",
        required=True,
        help="Path to the scanned/captured document or folder.",
    )
    parser.add_argument(
        "--threshold",
        type=float,
        default=0.95,
        help="Minimum required coverage ratio (default: 0.95).",
    )

    args = parser.parse_args()
    full_path = Path(args.full_path)
    scanned_path = Path(args.scanned_path)
    threshold = args.threshold

    if not full_path.exists():
        print(f"full_path does not exist: {full_path}")
        return 1

    if not scanned_path.exists():
        print(f"scanned_path does not exist: {scanned_path}")
        return 1

    # Require both to be same kind (both files OR both directories)
    if full_path.is_file() and not scanned_path.is_file():
        print("Type mismatch: full_path is a file but scanned_path is not.")
        return 1
    if full_path.is_dir() and not scanned_path.is_dir():
        print("Type mismatch: full_path is a directory but scanned_path is not.")
        return 1

    try:
        full_bytes = compute_bytes(full_path)
        scanned_bytes = compute_bytes(scanned_path)
    except FileNotFoundError as e:
        print(f"{e}")
        return 1

    if full_bytes == 0:
        print("full_path appears empty (0 bytes) - cannot compute coverage.")
        return 1

    coverage = scanned_bytes / full_bytes
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}% (threshold {threshold * 100:.2f}%)")

    if coverage < threshold:
        print("Coverage below required threshold - output prohibited under CBSP21.")
        return 1

    print("Coverage requirement satisfied - CBSP21 conditions met.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 17.2 Python Coverage Script with JSON Audit Log

Save as: `scripts/cbsp21_coverage_with_audit.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage & Audit Logger

Usage:
    python scripts/cbsp21_coverage_with_audit.py \
        --full full_source \
        --scanned scanned_source \
        --threshold 0.95 \
        --log logs/cbsp21_audit.jsonl
"""

import argparse
import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any


def total_bytes(root: Path) -> int:
    return sum(
        f.stat().st_size
        for f in root.rglob("*")
        if f.is_file()
    )


def build_audit_record(
    full: Path,
    scanned: Path,
    full_bytes: int,
    scanned_bytes: int,
    coverage: float,
    threshold: float,
    status: str,
) -> Dict[str, Any]:
    return {
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "policy": "CBSP21",
        "full_path": str(full),
        "scanned_path": str(scanned),
        "full_bytes": full_bytes,
        "scanned_bytes": scanned_bytes,
        "coverage_ratio": coverage,
        "coverage_percent": round(coverage * 100, 2),
        "threshold": threshold,
        "status": status,  # "pass" | "fail"
        # Optional CI metadata (if running in GitHub Actions, etc.)
        "ci": {
            "run_id": os.getenv("GITHUB_RUN_ID"),
            "run_number": os.getenv("GITHUB_RUN_NUMBER"),
            "sha": os.getenv("GITHUB_SHA"),
            "ref": os.getenv("GITHUB_REF"),
        },
    }


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--full", required=True, help="Path to full_source (immutable)")
    parser.add_argument("--scanned", required=True, help="Path to scanned_source")
    parser.add_argument("--threshold", type=float, default=0.95)
    parser.add_argument(
        "--log",
        default="logs/cbsp21_audit.jsonl",
        help="Path to append-only JSONL audit log",
    )
    args = parser.parse_args()

    full_root = Path(args.full)
    scanned_root = Path(args.scanned)
    threshold = args.threshold
    log_path = Path(args.log)

    # Basic existence checks
    if not full_root.exists():
        print(f"full_source path not found: {full_root}")
        return 1
    if not scanned_root.exists():
        print(f"scanned_source path not found: {scanned_root}")
        return 1

    # Immutability note: this script NEVER writes to full_root; it only reads.

    full_size = total_bytes(full_root)
    scanned_size = total_bytes(scanned_root)

    if full_size == 0:
        print("full_source appears empty - cannot compute coverage.")
        return 1

    coverage = scanned_size / full_size
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}% (threshold {threshold * 100:.2f}%)")

    status = "pass" if coverage >= threshold else "fail"

    # Ensure log directory exists
    log_path.parent.mkdir(parents=True, exist_ok=True)

    record = build_audit_record(
        full=full_root,
        scanned=scanned_root,
        full_bytes=full_size,
        scanned_bytes=scanned_size,
        coverage=coverage,
        threshold=threshold,
        status=status,
    )

    # Append JSON line
    with log_path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False))
        f.write("\n")

    if status == "fail":
        print("Coverage below CBSP21 threshold - output prohibited.")
        return 1

    print("Coverage requirement satisfied - CBSP21 conditions met.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 17.3 PowerShell Coverage Script

Save as: `scripts/Check-CBSP21Coverage.ps1`

```powershell
param(
    [Parameter(Mandatory = $true)]
    [string]$FullPath,

    [Parameter(Mandatory = $true)]
    [string]$ScannedPath,

    [double]$Threshold = 0.95
)

function Get-TotalBytes($Path) {
    Get-ChildItem -Recurse -File -Force $Path `
        | Measure-Object -Property Length -Sum `
        | Select-Object -ExpandProperty Sum
}

if (-not (Test-Path $FullPath)) {
    Write-Error "Full source path not found: $FullPath"
    exit 1
}

if (-not (Test-Path $ScannedPath)) {
    Write-Error "Scanned source path not found: $ScannedPath"
    exit 1
}

$fullBytes = Get-TotalBytes $FullPath
$scannedBytes = Get-TotalBytes $ScannedPath

if (-not $fullBytes) {
    Write-Error "Full source appears empty - cannot compute coverage."
    exit 1
}

$coverage = $scannedBytes / $fullBytes
$percent = "{0:N2}" -f ($coverage * 100)

Write-Host "CBSP21 Coverage: $percent%"

if ($coverage -lt $Threshold) {
    Write-Host "Coverage below $($Threshold * 100)% - Output prohibited."
    exit 1
}
else {
    Write-Host "Coverage requirement satisfied."
    exit 0
}
```

### 17.4 GitHub Actions Workflow

Save as: `.github/workflows/cbsp21_coverage.yml`

```yaml
name: CBSP21 Coverage Gate

on:
  pull_request:
  push:
    branches: [ main, master ]

jobs:
  cbsp21-coverage:
    runs-on: ubuntu-latest

    env:
      CBSP21_THRESHOLD: "0.95"   # change if policy updates

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Run CBSP21 Coverage Check
        run: |
          python <<'PYCODE'
          import os
          from pathlib import Path

          THRESHOLD = float(os.getenv("CBSP21_THRESHOLD", "0.95"))
          full = Path("full_source")
          scanned = Path("scanned_source")

          def total_bytes(root: Path):
              return sum(
                  f.stat().st_size
                  for f in root.rglob("*")
                  if f.is_file()
              )

          if not full.exists():
              raise SystemExit("full_source/ not found")
          if not scanned.exists():
              raise SystemExit("scanned_source/ not found")

          full_size = total_bytes(full)
          scanned_size = total_bytes(scanned)

          coverage = scanned_size / full_size if full_size else 0
          percentage = coverage * 100

          print(f"CBSP21 Coverage: {percentage:.2f}%")

          if coverage < THRESHOLD:
              print("Coverage below policy threshold. Output prohibited.")
              raise SystemExit(1)
          else:
              print("Coverage requirement satisfied.")
          PYCODE
```

---

## 18. Revision Notes

| Rev | Date | Notes |
|-----|------|-------|
| 1.0 | 2026-01-01 | Initial release. Establishes ≥95% coverage rule, STOP CONDITIONS, structured input preference, immutability rules, audit declaration requirement, and implementation scripts. |
| 1.1 | 2026-01-02 | Added repo-enforced CI gates, patch packet format validation, enhanced scripts with improved error handling, and operational rules. |

---

## 19. Repo Layout for CI Enforcement

Create these directories at repo root (or customize paths in workflows):

```
cbsp21/
  full_source/        # immutable ground truth (human controlled)
  scanned_source/     # scanned / captured representation used for coverage
  patch_packets/      # optional: structured FILE: packets (for patch-format rule)
logs/                 # optional: audit logs output
scripts/cbsp21/       # the gate scripts
```

---

## 20. Enhanced Implementation Scripts

### 20.1 Coverage Check (Enhanced)

**Path:** `scripts/cbsp21/cbsp21_coverage_check.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage Check

Calculates how much of the original content has been scanned/captured
and enforces a minimum coverage threshold (default: 95%).

- If both paths are files -> compare file sizes.
- If both paths are directories -> compare total bytes of all files.
- If one is a file and the other is a directory -> fail with an error.

Usage examples:

    # Directories
    python scripts/cbsp21/cbsp21_coverage_check.py \
        --full-path cbsp21/full_source \
        --scanned-path cbsp21/scanned_source \
        --threshold 0.95
"""

import argparse
from pathlib import Path


def total_bytes_in_dir(root: Path) -> int:
    """Sum bytes of all regular files under a directory (recursive)."""
    return sum(
        f.stat().st_size
        for f in root.rglob("*")
        if f.is_file()
    )


def compute_bytes(path: Path) -> int:
    """Return total bytes for a file or a directory."""
    if path.is_file():
        return path.stat().st_size
    if path.is_dir():
        return total_bytes_in_dir(path)
    raise ValueError(f"Path not found: {path}")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--full-path", required=True)
    ap.add_argument("--scanned-path", required=True)
    ap.add_argument("--threshold", type=float, default=0.95)
    args = ap.parse_args()

    full = Path(args.full_path)
    scanned = Path(args.scanned_path)

    if not full.exists():
        raise SystemExit(f"Full path does not exist: {full}")
    if not scanned.exists():
        raise SystemExit(f"Scanned path does not exist: {scanned}")

    # Guard: file vs dir mismatch
    if full.is_file() != scanned.is_file():
        raise SystemExit("CBSP21 ERROR: full-path and scanned-path must both be files or both be directories.")

    full_bytes = compute_bytes(full)
    scanned_bytes = compute_bytes(scanned)

    if not full_bytes:
        raise SystemExit("CBSP21 ERROR: full source appears empty - cannot compute coverage.")

    coverage = scanned_bytes / full_bytes
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}%")
    print(f"  full_bytes   = {full_bytes}")
    print(f"  scanned_bytes= {scanned_bytes}")
    print(f"  threshold    = {args.threshold * 100:.2f}%")

    if coverage < args.threshold:
        print("CBSP21 FAIL: Coverage below policy threshold. Output prohibited.")
        return 1

    print("CBSP21 PASS: Coverage requirement satisfied.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 20.2 Coverage + Audit Logger (Enhanced)

**Path:** `scripts/cbsp21/cbsp21_coverage_with_audit.py`

```python
#!/usr/bin/env python
"""
CBSP21 Coverage & Audit Logger

Usage:
    python scripts/cbsp21/cbsp21_coverage_with_audit.py \
        --full cbsp21/full_source \
        --scanned cbsp21/scanned_source \
        --threshold 0.95 \
        --log logs/cbsp21_audit.jsonl
"""

import argparse
import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict


def total_bytes_in_dir(root: Path) -> int:
    return sum(f.stat().st_size for f in root.rglob("*") if f.is_file())


def compute_bytes(path: Path) -> int:
    if path.is_file():
        return path.stat().st_size
    if path.is_dir():
        return total_bytes_in_dir(path)
    raise ValueError(f"Path not found: {path}")


def audit_record(
    *,
    full: Path,
    scanned: Path,
    full_bytes: int,
    scanned_bytes: int,
    coverage: float,
    threshold: float,
    status: str,
) -> Dict[str, Any]:
    return {
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "policy": "CBSP21",
        "full_path": str(full),
        "scanned_path": str(scanned),
        "full_bytes": full_bytes,
        "scanned_bytes": scanned_bytes,
        "coverage_ratio": coverage,
        "coverage_percent": round(coverage * 100, 2),
        "threshold": threshold,
        "status": status,  # "pass" | "fail"
        # Optional CI metadata (GitHub Actions)
        "ci": {
            "github_run_id": os.getenv("GITHUB_RUN_ID"),
            "github_sha": os.getenv("GITHUB_SHA"),
            "github_ref": os.getenv("GITHUB_REF"),
            "github_actor": os.getenv("GITHUB_ACTOR"),
            "github_repo": os.getenv("GITHUB_REPOSITORY"),
        },
    }


def append_jsonl(path: Path, rec: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(rec, ensure_ascii=False) + "\n")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--full", required=True)
    ap.add_argument("--scanned", required=True)
    ap.add_argument("--threshold", type=float, default=0.95)
    ap.add_argument("--log", required=True)
    args = ap.parse_args()

    full = Path(args.full)
    scanned = Path(args.scanned)
    log = Path(args.log)

    if not full.exists():
        print(f"CBSP21 FAIL: full path missing: {full}")
        rec = audit_record(full=full, scanned=scanned, full_bytes=0, scanned_bytes=0,
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    if not scanned.exists():
        print(f"CBSP21 FAIL: scanned path missing: {scanned}")
        rec = audit_record(full=full, scanned=scanned, full_bytes=compute_bytes(full), scanned_bytes=0,
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    # Guard: mismatch
    if full.is_file() != scanned.is_file():
        print("CBSP21 FAIL: full and scanned must both be files or both be directories.")
        rec = audit_record(full=full, scanned=scanned, full_bytes=compute_bytes(full), scanned_bytes=compute_bytes(scanned),
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    full_bytes = compute_bytes(full)
    scanned_bytes = compute_bytes(scanned)

    if not full_bytes:
        print("CBSP21 FAIL: full source empty.")
        rec = audit_record(full=full, scanned=scanned, full_bytes=0, scanned_bytes=scanned_bytes,
                           coverage=0.0, threshold=args.threshold, status="fail")
        append_jsonl(log, rec)
        return 1

    coverage = scanned_bytes / full_bytes
    percent = coverage * 100

    print(f"CBSP21 Coverage: {percent:.2f}% (threshold {args.threshold * 100:.2f}%)")

    status = "pass" if coverage >= args.threshold else "fail"
    rec = audit_record(
        full=full,
        scanned=scanned,
        full_bytes=full_bytes,
        scanned_bytes=scanned_bytes,
        coverage=coverage,
        threshold=args.threshold,
        status=status,
    )
    append_jsonl(log, rec)

    if status == "fail":
        print("CBSP21 FAIL: Coverage below policy threshold. Output prohibited.")
        return 1

    print("CBSP21 PASS: Coverage requirement satisfied.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 20.3 Patch Packet Format Validator

This enforces structured input rules:
- Must contain at least one `FILE: path/to/file.ext`
- Must have balanced triple-backtick fences
- Optional: blocks "..." placeholder lines inside code fences

**Path:** `scripts/cbsp21/check_patch_packet_format.py`

```python
#!/usr/bin/env python
"""
CBSP21 Patch Packet Format Rule

Validates that patch packets are structured and safe to scan:
- Must include at least one line starting with "FILE: "
- Code fences (```) must be balanced
- Optional: disallow "..." placeholder inside code fences (common truncation)

Usage:
    python scripts/cbsp21/check_patch_packet_format.py --glob "cbsp21/patch_packets/**/*.*"
"""

import argparse
import glob
from pathlib import Path


def balanced_fences(text: str) -> bool:
    return text.count("```") % 2 == 0


def has_file_headers(text: str) -> bool:
    return any(line.startswith("FILE: ") for line in text.splitlines())


def has_ellipsis_inside_code_fence(text: str) -> bool:
    in_fence = False
    for line in text.splitlines():
        if line.strip().startswith("```"):
            in_fence = not in_fence
            continue
        if in_fence and line.strip() == "...":
            return True
    return False


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--glob", required=True, help="Glob of packet files to validate.")
    ap.add_argument("--disallow-ellipsis-in-code", action="store_true")
    args = ap.parse_args()

    files = [Path(p) for p in glob.glob(args.glob, recursive=True)]
    files = [p for p in files if p.is_file()]

    if not files:
        print("CBSP21 Patch Packet: no files matched; skipping.")
        return 0

    failed = False

    for path in files:
        txt = path.read_text(encoding="utf-8", errors="ignore")

        if not has_file_headers(txt):
            print(f"CBSP21 PATCH FAIL: Missing FILE headers in {path}")
            failed = True

        if not balanced_fences(txt):
            print(f"CBSP21 PATCH FAIL: Unbalanced ``` fences in {path}")
            failed = True

        if args.disallow_ellipsis_in_code and has_ellipsis_inside_code_fence(txt):
            print(f"CBSP21 PATCH FAIL: Found '...' placeholder inside code fence in {path}")
            failed = True

    if failed:
        return 1

    print("CBSP21 Patch Packet: PASS")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### 20.4 CI Workflow: Coverage Gate

Runs only when CBSP21 material changes, so normal PRs are not blocked.

**Path:** `.github/workflows/cbsp21_coverage_gate.yml`

```yaml
name: CBSP21 Coverage Gate

on:
  pull_request:
    paths:
      - "cbsp21/**"
      - "scripts/cbsp21/**"
  push:
    branches: [ main, master ]
    paths:
      - "cbsp21/**"
      - "scripts/cbsp21/**"

jobs:
  cbsp21-coverage:
    runs-on: ubuntu-latest

    env:
      CBSP21_THRESHOLD: "0.95"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: CBSP21 Coverage + Audit
        run: |
          python scripts/cbsp21/cbsp21_coverage_with_audit.py \
            --full cbsp21/full_source \
            --scanned cbsp21/scanned_source \
            --threshold $CBSP21_THRESHOLD \
            --log logs/cbsp21_audit.jsonl

      - name: Upload CBSP21 audit log
        uses: actions/upload-artifact@v4
        with:
          name: cbsp21_audit
          path: logs/cbsp21_audit.jsonl
```

### 20.5 CI Workflow: Patch Packet Format

Enforces structured `FILE:` packet format when patch packets change.

**Path:** `.github/workflows/cbsp21_patch_packet_format.yml`

```yaml
name: CBSP21 Patch Packet Format

on:
  pull_request:
    paths:
      - "cbsp21/patch_packets/**"
      - "scripts/cbsp21/**"

jobs:
  cbsp21-patch-format:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Validate CBSP21 patch packets
        run: |
          python scripts/cbsp21/check_patch_packet_format.py \
            --glob "cbsp21/patch_packets/**/*.*" \
            --disallow-ellipsis-in-code
```

---

## 21. Operational Rules

### 21.1 Reconstituting a Chat / Ensuring Completeness

1. Put the authoritative material into:
   - `cbsp21/full_source/` (read-only by convention)

2. Put the scanned/captured material into:
   - `cbsp21/scanned_source/`

3. CI enforces **≥95% coverage**.

### 21.2 Submitting Patch Packets Safely

Put them in `cbsp21/patch_packets/` using:

```text
FILE: services/api/app/whatever.py
<full content or a full diff>
```

CI enforces:
- At least one `FILE:` header
- Balanced code fences
- No "..." truncation inside code fences

---

## 22. Optional Hardening

If you decide you want CBSP21 enforced for *all PRs touching governed areas* (RMOS/CAM/etc.), add another workflow trigger:

- If PR touches `services/api/app/rmos/**` or `packages/client/src/components/rmos/**`
- Then require `cbsp21/full_source` + `cbsp21/scanned_source` exist and pass

This is not enabled by default because it can block everyday development unless the team is ready for that discipline.

---

**End of CBSP21**
