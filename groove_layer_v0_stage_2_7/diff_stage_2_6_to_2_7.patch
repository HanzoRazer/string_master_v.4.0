--- stage_2_6/groove_layer/engine.py
+++ stage_2_7/groove_layer/engine.py
@@ -1,18 +1,16 @@
 from __future__ import annotations
 
-from dataclasses import dataclass, asdict
-from typing import Dict, Any, Optional
+from dataclasses import dataclass, asdict, field
+from typing import Dict, Any, Optional, List
 
 
 @dataclass
 class GrooveStateV0:
-    """Minimal state container for Stage 2.6.
-
-    Adds probe scheduling + cooldown decay on top of Stage 2.5.
-
-    Concepts:
-    - `probe_cooldown_windows`: blocks starting new probes (decays each window).
-    - `next_probe_in_windows`: deterministic scheduler so probes don't fire every stable window.
+    """Minimal state container for Stage 2.7.
+
+    Adds Vector 07: probe success scoring + persist probe outcomes.
+
+    Persistence in v0 is *in-memory only* (state object). Higher layers can store state.
     """
     last_loop_policy: str = "none"
     last_density: str = "medium"
@@ -30,11 +28,22 @@
     next_probe_in_windows: int = 0  # counts down; when hits 0 and stable, we may probe
     probe_interval_windows: int = 3 # schedule next probe this many stable windows later
 
+    # Probe outcomes (Vector 07)
+    probe_last_score: float = 0.0
+    probe_last_outcome: str = "unknown"  # success | fail | unknown
+    probe_history: List[Dict[str, Any]] = field(default_factory=list)
+
 
 def _avg_conf(events) -> float:
     if not events:
         return 0.0
     return sum(e.get("confidence", 0.0) for e in events) / len(events)
+
+
+def _avg_strength(events) -> float:
+    if not events:
+        return 0.0
+    return sum(float(e.get("strength", 0.0)) for e in events) / len(events)
 
 
 def _is_stable(event_count: int, avg_conf: float) -> bool:
@@ -55,6 +64,9 @@
 
     state.next_probe_in_windows = prior.get("next_probe_in_windows", state.next_probe_in_windows)
     state.probe_interval_windows = prior.get("probe_interval_windows", state.probe_interval_windows)
+
+    state.probe_last_score = prior.get("probe_last_score", state.probe_last_score)
+    state.probe_last_outcome = prior.get("probe_last_outcome", state.probe_last_outcome)
 
 
 def _controls_baseline(engine_context: Dict[str, Any]) -> Dict[str, Any]:
@@ -68,12 +80,43 @@
     }
 
 
+def _score_probe_window(events) -> float:
+    """v0 scoring heuristic (Vector 07).
+
+    Proxy score in [0,1] from available event fields:
+    - confidence (stability proxy)
+    - strength (engagement proxy)
+    """
+    c = _avg_conf(events)
+    s = _avg_strength(events)
+    score = 0.75 * c + 0.25 * s
+    return max(0.0, min(1.0, score))
+
+
+def _apply_probe_outcome(state: GrooveStateV0, score: float) -> None:
+    """Persist outcome and adapt schedule (v0 minimal).
+
+    - success (>=0.90): probe more often (interval -1, min 2)
+    - fail    (<0.90): probe less often (interval +1, max 6) and add cooldown (3)
+    """
+    outcome = "success" if score >= 0.90 else "fail"
+    state.probe_last_score = float(score)
+    state.probe_last_outcome = outcome
+    state.probe_history.append({"outcome": outcome, "score": float(score)})
+
+    if outcome == "success":
+        state.probe_interval_windows = max(2, int(state.probe_interval_windows) - 1)
+    else:
+        state.probe_interval_windows = min(6, int(state.probe_interval_windows) + 1)
+        state.probe_cooldown_windows = max(state.probe_cooldown_windows, 3)
+
+
 def compute_groove_layer_control(payload: Dict[str, Any], state: Optional[GrooveStateV0] = None) -> Dict[str, Any]:
     """Compute Groove Layer v0 control intent.
 
-    Stage 2.6 adds Vector 06:
-      - Probe cooldown decay (explicit + testable)
-      - Probe scheduling (deterministic spacing between probes)
+    Stage 2.7 adds Vector 07:
+      - when a probe completes (after its active window), score it and persist outcome
+      - adjust probe_interval_windows based on outcome
     """
     if state is None:
         state = GrooveStateV0()
@@ -120,23 +163,23 @@
     if state.probe_cooldown_windows > 0:
         state.probe_cooldown_windows -= 1
 
-    # Scheduler only ticks down on stable windows (avoid "countdown while struggling")
+    # Scheduler only ticks down on stable windows
     if stable and state.next_probe_in_windows > 0:
         state.next_probe_in_windows -= 1
 
     state.stable_windows = state.stable_windows + 1 if stable else 0
 
     # --- Hard instability corrective mode (Vector 02)
-    # If probing and instability is detected, revert immediately + cooldown.
     if (avg_conf < 0.85) or (event_count < 8):
         if state.probe_active:
+            # Probe is active but instability hit: revert and DO NOT score (probe invalidated)
             state.probe_active = False
             state.probe_kind = ""
             state.probe_variant = ""
             state.probe_windows = 0
             state.probe_cooldown_windows = 8
             state.last_density = state.probe_baseline_density
-            state.next_probe_in_windows = state.probe_interval_windows  # push future probes out
+            state.next_probe_in_windows = state.probe_interval_windows
 
             return {
                 "schema_id": "groove_layer_control",
@@ -196,11 +239,6 @@
         state.last_density = "medium"
 
     # --- Probing + scheduling (Vector 06)
-    # Rules (v0):
-    # - Never start a probe if cooldown > 0.
-    # - Only start a probe on stable windows, after at least 2 stable windows.
-    # - Only start if scheduler counter is 0.
-    # - When a probe starts, set next_probe_in_windows = probe_interval_windows.
     if stable and (state.probe_cooldown_windows == 0) and (state.stable_windows >= 2) and (state.next_probe_in_windows == 0) and (not state.probe_active):
         state.probe_active = True
         state.probe_kind = "density"
@@ -221,16 +259,32 @@
             "debug": {"state": asdict(state), "reason": "probe_start_scheduled_density_dense"}
         }
 
-    # Probe active: keep the probed density for 1 window then end probe (v0 minimal)
+    # --- Probe active (Vector 05) + score on completion (Vector 07)
     if state.probe_active:
         state.probe_windows += 1
         controls = _controls_baseline(engine_context)
         controls["arrangement"]["density_target"] = state.last_density
+
+        # v0: probe lasts for exactly one window; score on completion
         if state.probe_windows >= 1:
+            score = _score_probe_window(events)
+            _apply_probe_outcome(state, score)
+
             state.probe_active = False
             state.probe_kind = ""
             state.probe_variant = ""
             state.probe_windows = 0
+            state.last_density = "medium"
+
+            return {
+                "schema_id": "groove_layer_control",
+                "schema_version": "v0",
+                "device_id": device_id,
+                "session_id": session_id,
+                "controls": controls,
+                "debug": {"state": asdict(state), "reason": "probe_complete_scored"}
+            }
+
         return {
             "schema_id": "groove_layer_control",
             "schema_version": "v0",

--- stage_2_6/tests/test_groove_layer_stage_2_3.py
+++ stage_2_7/tests/test_groove_layer_stage_2_3.py
@@ -64,3 +64,21 @@
     state = GrooveStateV0(stable_windows=2, probe_cooldown_windows=0, next_probe_in_windows=1)
     out = compute_groove_layer_control(payload, state=state)
     assert out["controls"]["arrangement"]["density_target"] == "medium"
+
+
+def test_vector_07a_probe_success_decreases_interval():
+    payload = load("fixtures/vectors/07a_probe_success_decreases_interval.json")
+    state = GrooveStateV0(probe_active=True, last_density="dense", probe_interval_windows=3)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["debug"]["reason"] == "probe_complete_scored"
+    assert out["debug"]["state"]["probe_last_outcome"] == "success"
+    assert out["debug"]["state"]["probe_interval_windows"] == 2
+
+def test_vector_07b_probe_fail_increases_interval_sets_cooldown():
+    payload = load("fixtures/vectors/07b_probe_fail_increases_interval_sets_cooldown.json")
+    state = GrooveStateV0(probe_active=True, last_density="dense", probe_interval_windows=3)
+    out = compute_groove_layer_control(payload, state=state)
+    assert out["debug"]["reason"] == "probe_complete_scored"
+    assert out["debug"]["state"]["probe_last_outcome"] == "fail"
+    assert out["debug"]["state"]["probe_interval_windows"] == 4
+    assert out["debug"]["state"]["probe_cooldown_windows"] >= 2

